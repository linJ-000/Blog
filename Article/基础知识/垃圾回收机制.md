# 垃圾回收机制

JavaScript 在创建变量的时候会自动分配内存空间，并在使用完毕后自动释放，这一过程称为垃圾回收。但 JavaScript 的垃圾回收并不能使我们高枕无忧，稍不注意就会写出内存泄漏的代码。

## JavaScript 的内存管理

垃圾回收机制要从 JavaScript 的内存管理说起。

内存分为堆和栈，或者叫执行栈和内存堆。栈一般用来存放基础类型如数字，字符串；堆用来存放复杂类型，如对象；数组。实际上，复杂类型会在栈中保存其在堆中的内存地址。

当函数执行时，函数执行上下文就会被压入栈中，等函数执行完毕再出栈。可以认为，栈是用来保存一些临时变量的。而基本类型也不全是保存在栈中，当一个变量被闭包引用时，就会长期存在，即使是基本类型，也会被保存在堆中。

## 垃圾回收算法

### 分代回收

垃圾回收是针对堆中的对象。

V8 中将内存分为**新生代**（new space）和**老生代**（old space）。新生代中的对象存活时间短，为未经历过垃圾回收或只经历过一次垃圾回收的对象。老生代中对象存活时间长，一般是经历过多次垃圾回收的对象。

基于“新生的对象偏向于早死，不死的对象会存活的更久”这样的时代假说，老生代的对象不必进行频繁的检测，新生代和老生代由不同的算法进行垃圾回收。通过这样**分代回收**的策略提高垃圾回收算法的效率。

### Scavenge

新生代清理发生的十分频繁，所以清理需要十分快速。V8 中对新生代的垃圾回收采用 Scavenge 算法，是按照 Cheney 算法实现的。该算法将新生代分为两个等大的子区：From 空间（出区）和 To 空间（入区）。

* 绝大部分的内存分配都会发生在 From 空间。
* 当 From 空间耗尽时，交换 From 空间和 To 空间。
* 对 To 空间中的对象进行检测，将活跃的对象复制到 From 空间或老生代，将不活跃的对象内存空间释放。

那么怎么判断是将活跃对象复制到 From 空间还是老生代空间呢？要去到老空间需要符合两个条件的其中之一：

1. 已经经历过一次 Scavenge 算法
2. From 空间使用超过 25%

这个过程称为**对象晋升**。

### Mark-Sweep 和 Mark-Compact

Scavenge 算法对于快速回收的小块内存效果很好，但对于老生代存活对象多，存活时间长的场景就不合适了。不仅复制大量对象消耗性能，还有浪费一半空间。在老生代采用 Mark-Sweep（标记-清除）和 Mark-Compact（标记-紧缩）算法。

Mark-Sweep 算法和 Mark-Compact 算法都会经历两个阶段会经历标记、清除或紧缩。

标记算法的核心和深度搜索优先，它会将检索堆上的所有活跃对象，并将不活跃对象（对象及其引用的对象都检索完毕）标记。

接下来将选择清除或紧缩，这两者都能回收内存。直接清除会导致内存碎片化，下次需要给一个大对象分配内存时可能找不到一个支持的内存碎片。紧缩算法则会将活跃对象迁移到一起，将标记对象放在边缘，等待下次垃圾回收。但紧缩算法需要移动对象，执行速度慢，因此 V8 主要使用 Mark-Sweep 算法，当内存不足时使用 Mark-Compact 算法。

### 增量标记和惰性清理

除了分代回收外，V8 还通过增量标记和惰性清理提高垃圾回收的效率。

当一个堆很大且有很多活跃对象时，Mark-Sweep 和 Mark-Compact 依旧会执行得很慢。而当垃圾回收进行时，会中断逻辑代码，称为**全停顿**（Stop The World）。

增量标记将标记阶段分称多个小步，与应用逻辑交替执行，将一个大停顿分割成多个 5~10ms 的小停顿，同时不阻塞应用逻辑。

当增量标记完成后，所有对象都被处理完成，非死即活。堆上剩余多少空间已经确定，清理过程可以被延迟，垃圾回收器根据需要逐一清理。当清理完毕后，增量标记又重新开始。

## 内存泄漏

内存泄漏指的是那些不需要的对象仍然占用内存，无法被垃圾回收清理，内存无法释放。

一下情况可能会造成内存泄漏：

1. 全局变量。浏览器中，全局变量会作为 window 对象的属性，只有当页面关闭才会被清理。
2. 未销毁的定时器和回调。
3. 闭包。闭包让函数即使在外部调用仍能访问其词法作用域，那该作用内的变量和对象都需被保存，无法释放。
4. DOM 的不规范引用。将 DOM 的引用保存在数组或对象中时，即使 DOM 被删除，其引用的内存仍然无法释放。ES6 中引入 WeakSet 和 WeakMap 两个概念，来解决引用造成的垃圾回收问题。他们对值得引用是弱引用，不会被垃圾回收器统计，当他们引用的对象在外部消失时，WeakSet 和 WeakMap 内部的引用也会消失，该对象占用的内存将会被释放。