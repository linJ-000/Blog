# 原型和原型链

JavaScript 对象有一个特殊的内置属性 [[prototype]]，其实就是对其他对象的引用。可通过 `__proto__` 直接访问 [[prototype]]。

**对象属性的访问**

当引用对象的属性时，会现在对象本身的属性上进行查找。如果无法在对象本身找到需要的属性，就会访问对象的 [[prototype]]。如果其 [[prototype]] 所指向的对象也找不到的话，则会继续查找该对象的 [[prototype]]，知道查找完整条 [[prototype]] 链。

使用 `for...in` 遍历对象与查找对象属性类似，[[prototype]] 链上可枚举（`enumerable:true`）的属性都会被遍历。

所有普通的 [[prototype]] 链最终都会指向内置的 `Object.prototype`。`toString()`、`valueOf()` 和其他一些通用功能都存在于 `Object.prototype` 对象上，因此语言中的所有对象都可以使用它们。

**对象属性的设置**

当设置对象的属性时，如果对象和 [[prototype]] 都不存在该属性，则会直接添加到对象上。如果对象中不存在，而 [[prototype]] 中存在，则需要分多种情况：

1. [[prototype]] 链中存在，且没有被标记为已读（`writable:false`），则会在对象中添加一个属性。
2. [[prototype]] 链中存在，但被标记为已读（`writable:true`），则赋值语句无效，在严格模式下会报错。
3. [[prototype]] 链中存在， 并且它是一个 setter，则这个 setter 一定会被调用。

## “类”

JavaScript 并不是一门基于类的语言，但我们常常用原型来模拟类。但与真正的类还是有很多不同。

类可以被实例化，实例化时会将类的属性复制，实例化出的对象互不关联。在 JavaScript 中没有类，只有对象。通过 new 作用于构造函数来模拟类的实例化。而所谓的构造函数也是一个普通的函数，当被 new 调用时会返回一个对象，这个对象会关联构造函数的原型对象。上面说到原型 [[prototype]] 其实是一种对象之间的联系，通过 new 可以建立这种联系。如 `new Foo()` 生成的对象其 [[prototype]] 都会指向 `Foo.prototype`。

另一种创建对象联系的方法是 `Object.create()`。该方法传入一个对象作为参数，返回一个新的对象，该对象的原型指向传入对象的原型。如果用类来理解，可以说是通过一个实例创建另一个实例。

通过建立这种联系，构造函数原型上的属性（一般是一些公共方法）能被 new 生成的对象访问。包括 `constructor` 属性（该属性的默认值为构造函数），也是在构造函数原型上，生成的对象通过原型链访问。