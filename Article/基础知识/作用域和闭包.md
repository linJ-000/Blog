# 作用域和闭包

## 作用域

作用域是查找变量的一套规则，也可理解为变量和声明的作用范围。对变量进行赋值或者获取变量值时，会先在当前作用域查找，如果没有找到，则会在上一级作用域查找，自上而下形成一条作用域链。因此能通过作用域链访问父级作用域中声明的变量。

### 词法作用域

JavaScript的作用域为词法作用域（另一种为动态作用域）。编译器有一个叫词法化的工作阶段，词法作用域就是定义在词法阶段的作用域。即词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

### eval和with

eval和with可以改变词法作用域，但这两个方法会被严格模式`use strict`限制。同时，使用这两个方法会导致性能问题。因JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。eval和with能动态改变词法作用域，使得词法分析优化失效。

### javascript中的作用域
JavaScript常见的作用域是函数作用域（具名函数、匿名函数、立即执行函数）。通过`with`和`try/catch`可以形成块级作用域。ES6中的`let`和`const`关键字可以使其声明的变量拥有块级作用域。

### 变量提升
函数声明和变量声明会被提升到作用域顶部（变量声明只提升声明，不提升赋值）。当有多个重复声明时，函数声明会被提升到变量声明之前。

## 闭包
函数对定义时词法作用的引用即为闭包。通过某些手段将函数在其词法作用域外调用，该函数仍能访问到其词法作用域。闭包同时使得其词法作用域的变量可能不会被垃圾回收机制回收。

```js
var a = {}
;(function() { // 匿名函数形成一个作用域，该作用域为函数print的词法作用域
    var str = 'hello world'
    
    function print() {
        console.log(str)
    }
    
    a.print = print
})()

// 函数print在词法作用域外调用，仍能访问其词法作用域内的str变量
a.print() // 'hello world'
```

### 回调函数
回调函数是闭包常见的例子。
```js
var a = 'hello world'
$('.selector').click(function() {
    // 该匿名函数的词法作用域为全局作用域
    // 该函数作为点击的回调函数，并非在全局作用域内调用
    // 该函数仍能访问到其词法作用域定义的变量a
	console.log(a)
})
```

### 循环
循环是闭包另一个常见的例子
```js
for (var i=1; i<=5; i++) {
    setTimeout( function() {
        console.log( i );
    }, i*1000 );
}
```
上述代码在执行之后会每秒打印一个6，而不是1到6。这是因为定时器接受的匿名函数在定义时共享同一个作用域，该作用域内只有一个i。循环结束，定时器开始执行的时候，此时共享作用域内的i为6。

解决方法如下，通过循环创建不同的作用域，用于保存不同的i
```js
// 以下方法是行不通的，此时的i仍处于我们构造的匿名函数的外部
for (var i = 1; i <= 5; i++) {
    (function () {
        setTimeout(function () {
        	console.log(i);
    	}, i * 1000);
    })()
}
// 将i赋值给我们构造的匿名函数内部的一个变量
// 每个循环都将创建一个作用域，每个作用域中保存不同的i
for (var i = 1; i <= 5; i ++) {
    (function () {
        var j = i
        setTimeout(function() {
        	console.log(j);
    	}, j * 1000);
    })()
}
// 简化如下
for (var i = 1; i <= 5; i++) {
    (function (j) {
        setTimeout(function() {
        	console.log(j);
    	}, j * 1000);
    })(i)
}
// 通过let关键词创建的块级作用域也可以实现
for (let i = 1; i <= 5; i++) {
    setTimeout(function() {
        console.log(i);
    }, i * 1000);
}
```

### 闭包与模块化
闭包能够隐藏词法作用域内的变量，因此也可以用来实现模块化。
