# 部署前端文件的缓存问题

由于浏览器缓存，CDN缓存等原因，更新到服务器上的前端资源文件有时候不能马上地访问到。控制缓存，刷新缓存地方法也经历了多个阶段。

## 时间戳/版本号

通过在资源地址上加上参数来刷新浏览器缓存

```html
<script src="//xxx.com/index.js?v=1.0">
<script src="//xxx.com/main.js?t=1599663364068">
```
这种方法可以有效的刷新浏览器缓存，但同样有缺点。那就是一些一般不更新的库，每次更新后都需要重新下载，带来一些性能损耗。

## 内容哈希

解决上面那个问题，地址上的参数进化成了另一种，hash。根据文件内容算出hash值，如果文件内容没有更新，那么hash值没有变化，部署之后，没更新的文件依旧可以读缓存。

## CDN的缓存

上述的方法并不能解决CDN缓存的问题。CDN缓存更新的比较慢，而且当CDN上存在文件时，不会去回源获取同名文件，改变参数并不能刷新CDN缓存。

由此演变出另一种方法：文件名hash。
```html
<script src="//xxx.com/main-e7081dd7a127798aa56a.js">
```
部署更新文件时，文件名改变，CDN找不到新文件，回去源站获取新文件，更新缓存。同时也能解决浏览器缓存的问题。

## webpack中的hash

文件名hash，配合webapck中的配置，可以说是一个完美解决缓存更新的方案。webpack中的hash有三种：

1. hash

    webpack中每次构建都会生成一个新的hash，通过这个hash可以更新所有文件。

2. chunkhash

    chunkhash指的是入口文件的hash，每个入口文件都会打包出一个hash值，当入口文件及其依赖更新时，chunkhash就会更新。

3. contenthash

    chunkhash存在这样的问题，当抽离出css文件时，css本身没有变化，但却因为入口文件的改变而使得hash值改变；另一方面，只修改css文件，webpack并不能监听到css文件的变化，从而导致hash值不能更新。contenthash很好地解决了这些问题。contenthash是通过打包出来文件内容计算出来的，只跟文件内容有关。
